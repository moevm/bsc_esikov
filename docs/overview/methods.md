## Типы плагиата фрагментов исходного кода

1. I тип — полностью совпадающие фрагменты, допускающие добавление пробельных символов и комментариев.
2. II тип — допускается переименование переменных, функций, классов.
3. III тип — допускается изменение, удаление и добавление операторов.
4. IV тип — фрагменты синтаксически написаны по-разному, но выполняют одинаковые вычисления.

Выявление IV типа совпадений не требуется, поскольку это означает выполнение задания студентом совершенно по-другому.
Основная задача метода — обнаружение совпадений I и II типа.
Также желательно, чтобы метод был способен обнаруживать и совпадения III типа.

## Методы

1. String based - исходный код сравнивается как есть. 
Абсолютно не подходит, поскольку даже совпадения I типа не всегда способен обнаружить.
2. Metric based - вычисляются определённые атрибуты исходного кода, из которых составляется вектор значений.
Показателем схожести программ будет расстояние между векторами. 
Имеет слишком высокую вероятность ошибки.
3. Tree based - происходит построение абстрактного синтаксического дерева программы.
После чего сравниваются построенные деревья. 
Является крайне трудоёмким и не подходит для поиска в большом количестве репозиториев на github.
4. Token based - исходный код программы представляется в виде токенов.
Большинство существующих систем используют именно этот метод, но используют различные алгоритмы для поиска совпадений.
Подробнее эти алгоритмы рассмотрены в следующем разделе.
5. Semantic - по исходному коду программы строится граф программных зависимостей. 
Способен обнаруживать совпадения всех типов.
Требуется алгоритм сравнения графов устойчивый к добавлению функций, возвращающих пустой результат или результат в неизменном виде.
Не подходит из-за высокой трудоёмкости поиска.

## Token based алгоритмы

### Алгоритм жадного строкового замощения

Выполняется поиск наибольших общих подстрок, состоящих из неотмеченных элементов.
Символы, входящие в найденные подстроки, отмечаются.
Если длина найденных подстрок остаётся больше порогового значения, то снова начинается поиск.
Алгоритм возвращает множество общих непересекающихся подстрок.

### Алгоритм Хескела

Полученная строка токенов делится на n-граммы (подстроки длины n).
Подсчёт уникальных n-грамм в программе.
В качестве коэффициента сходства рассматривается коэффициент Жаккара:
![](https://latex.codecogs.com/gif.latex?J%28A%2C%20B%29%20%3D%5Cfrac%7B%7D%7B%7D%20%5Cfrac%7B%7CA%20%5Ccap%20B%7C%7D%7B%7CA%20%5Ccup%20B%7C%7D)
, где A и B - множества уникальных n-грамм в сравниваемых программах, |A| - мощность множества.

### Метод отпечатков

В полученной строке токенов выполняется хеширование подстрок длины k.
Выделяется некоторое множество значений хеша, которое характеризует исследуемую программу.
Выполняется сравнение со значениями хеша для другой программы.
Ключевым моментом является выбор оптимального k и множества значений хеша.
Выбирать множество значений, характеризующих можно с помощью метода просеивания, который гарантирует, что если в двух файлах есть хотя бы одна достаточно длинная подстрока длины k, то как минимум одна метка в их наборах совпадёт.

### Колмогоровская сложность

В этом алгоритме используется расстояние между последовательностями, основанное на колмогоровской сложности последовательности.
Для вычисления схожести используется эвристика, основанная на сжатии токенизированного представления программы:
![](https://latex.codecogs.com/gif.latex?d%28x%2Cy%29%20%5Capprox%201%20-%20%5Cfrac%7BComp%28x%29%20-%20Comp%28x%7Cy%29%7D%7BComp%28xy%29%7D)
, где Comp(x) - длина сжатой строки.
В качестве сжатия используется алгоритм семейства LZ, использующий найденные неточные совпадения.
Чем ближе d(x,y) к 0, тем больше общей информации содержат программы.

## Выводы

Поиск плагиата в github-репозиториях предполагает большое количество сравнений, поэтому наиболее целесообразно использовать token based алгоритмы, имеющие линейную трудоёмкость — алгоритм Хескела или метод отпечатков.
Эти методы эффективно обнаруживают совпадения I и II типа, а также способны выявлять совпадения и III типа.
Однако результат их работы — это процент сходства, поэтому целесообразно применять вместе с ними алгоритм жадного строкового замощения, который имеет кубическую трудоёмкость, для определения заимствованных фрагментов в найденном репозитории с плагиатом.
